<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="disshu">
  <!-- Open Graph Data -->
  <meta property="og:title" content="实习面经">
  <meta property="og:description" content>
  <meta property="og:site_name" content="disshu">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="disshu" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>disshu</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/disshu.github.io/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/disshu.github.io/css/style.dark.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/disshu.github.io//img/cumt.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">实习面经</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/disshu.github.io/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/disshu.github.io/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/disshu">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:15695257867@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By disshu</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-03-18</span>
            <span class="time">22:05:00</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>腾讯 创宇 安恒 默安</p>
<a id="more"></a>
<h1 id="知道创宇"><a href="#知道创宇" class="headerlink" title="知道创宇"></a>知道创宇</h1><p>1.tcp udp区别<br>2.msf使用<br>3.git使用</p>
<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><p>sqlmap插件<br>算法题：100个数找十个最大的 堆排序<br>ctf题<br>#安恒渗透(上海)<br>1.做过哪些实战 靶机等<br>2.dvwa一些操作<br>3.遇到过哪些漏洞<br>4.sql注入,xss,csrf,ssrf原理 应用 脱库 qq诈骗 打开摄像头等</p>
<h4 id="sql注入防御"><a href="#sql注入防御" class="headerlink" title="sql注入防御"></a>sql注入防御</h4><p>这里采用了PreparedStatement，就会将sql语句预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是什么，都不会影响该sql语句的 语法结构了，因为语法分析已经完成了，而语法分析主要是分析sql命令，比如 select ,from ,where ,and, or ,order by 等等。所以即使你后面输入了这些sql命令，也不会被当成sql命令来执行了，因为这些sql命令的执行， 必须先的通过语法分析，生成执行计划，既然语法分析已经完成，已经预编译过了，那么后面输入的参数，是绝对不可能作为sql命令来执行的，只会被当做字符串字面值参数。所以sql语句预编译可以防御sql注入</p>
<p>讲一下另外一个预编译，就是用PDO，这里就推荐几篇文章自己看一下，<br>通过启用php.ini配置文件中的magic_quote_gpc (魔术字符)，就可以将大部分想利用SQL注入漏洞的骇客拒绝于门外。开启magic_quote_gpc=on之后，能实现addslshes()和stripslashes()这两个函数的功能，这就从很大程度上防止了sql注入</p>
<h4 id="xss防御"><a href="#xss防御" class="headerlink" title="xss防御"></a>xss防御</h4><p>过滤、&lt;&gt;<br>设置httponly 防止读取httponly</p>
<pre><code class="hljs undefined">Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。
XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意的特殊目的。
<span class="hljs-number">1.</span>反射型XSS：
&lt;非持久化&gt; 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。
<span class="hljs-number">2.</span>存储型XSS：
&lt;持久化&gt; 代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。
<span class="hljs-number">3.</span>DOM型XSS：
基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。</code></pre>

<h4 id="csrf如何防御"><a href="#csrf如何防御" class="headerlink" title="csrf如何防御"></a>csrf如何防御</h4><p>检测Referer头的方法是可靠的。<br>验证token</p>
<p>ssrf能够请求到与它相连但与外网隔离的内部系统。<br>ssrf内网渗透<br>5.sqlmap get post跑包 列出多种<br>6.给了两个应用场景 购物车如果渗透<br>7.登陆页面如果渗透<br>8.用过哪些扫描器<br>9.get请求包头部常见有哪些 XFF? referer token cookie<br>10.逻辑漏洞有哪些 越权<br>#安恒渗透(北京)<br>1.sqlmap post跑包 两种 –data -r<br>2.sqlmap 列出当前库</p>
<pre><code class="hljs undefined">sqlmap -u <span class="hljs-selector-attr">[“url”]</span> --dbs #获取数据库
sqlmap -u <span class="hljs-selector-attr">[“url”]</span> --current-user #获取当前用户名称 ：
sqlmap -u <span class="hljs-selector-attr">[“url”]</span> --current-db #获取当前数据库名称
sqlmap -u <span class="hljs-selector-attr">[“url”]</span> -D <span class="hljs-selector-attr">[‘数据库名’]</span> --tables   #列出表名 ： 
sqlmap -u <span class="hljs-selector-attr">[“url”]</span> -D <span class="hljs-selector-attr">[‘数据库名’]</span> -T<span class="hljs-selector-attr">[‘表名’]</span> --<span class="hljs-attribute">columns</span> #列出字段 
sqlmap -u <span class="hljs-selector-attr">[“url”]</span> -D <span class="hljs-selector-attr">[‘数据库名’]</span> -T <span class="hljs-selector-attr">[‘表名’]</span> -C <span class="hljs-selector-attr">[‘字段名1,字段名2,…’]</span> --dump #获取字段内容</code></pre>

<p>3.如何扫描出cms的信息</p>
<p>扫描cms<br>1,指纹识别，就是网站标识识别，代表有whatweb，御剑等<br>2,网站框架识别，多瞅多观察，cms不冷门一般很好识别<br>3,后台，图片，等路径<br>4,版权5,<br>好好扫扫这个站有没有version,txt一类的玩意出现在根目录注：现在很多站二次开发只取部分程序，所以不是很好分辨，还要多试的<br> SSRF(服务器请求伪造)<br> 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。<br> 访问内网<br>url到页面请求<br>1、输入网址<br>2、DNS解析<br>3、建立tcp连接<br>4、客户端发送HTTP请求<br>5、服务器处理请求　<br>6、服务器响应请求<br>7、浏览器展示HTML<br>8、浏览器发送请求获取其他在HTML中的资源。<br>XXE产生原因<br>当包含对外部实体的引用的XML输入被弱配置XML解析器处理时，就会发生这种攻击。这种攻击通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p>
<h4 id="csrf原理"><a href="#csrf原理" class="headerlink" title="csrf原理"></a>csrf原理</h4><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。<br>httponly获取cookie<br>H5环境下可以利用cors<br>一些服务器报错页<br>cookie过长 溢出<br>常见CMS漏洞<br>443 http<br>445 共享目录</p>
<hr>
<p>dns协议<br>DNS协议就是用来将域名解析到IP地址的一种协议，当然，也可以将IP地址转换为域名的一种协议。<br>DNS协议基于UDP和TCP协议的，端口号53，用户到服务器采用UDP，DNS服务器通信采用TCP<br>大型运营商、互联网机构等会向公众提供免费的DNS服务，例如，谷歌的8.8.8.8 8.8.4.4 阿里巴巴223.5.5.5 223.6.6.6<br>域名服务器主要分为：根域名服务器、顶级域名服务器、权限域名服务器、本地域名服务器。</p>
<p>域名到IP地址的解析过程的要点如下：<br>当某一个应用需要把主机名解析为IP地址时，该应用进程就调用解析程序，并称为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。<br>本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用程序获得目的主机的IP地址后即可进行通信。<br>若本地域名服务器不能回答该请求，则此域名服务器就暂时称为DNS的另一个客户，并向其他域名服务器发出查询请求。</p>
<p>一、主机向本地域名服务器的查询一般都是采用递归查询。<br>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。<br>二、本地域名服务器向根域名服务器的查询的迭代查询。<br>迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</p>
<hr>
<p>首先，我们输入的网址，这是一个URL。但是浏览器并不知道这个地址如何访问，所以需要使用DNS协议，去查找它的IP地址。</p>
<p>你会留意到，有些网站是用http开头，有些则是用https开头的。HTTP协议是非加密协议，而HTTPS是一个加密协议，对于需要加密传输的数据，可以使用HTTPS协议。</p>
<p>应用层</p>
<p>刚才提到的DNS/HTTP/HTTPS协议，都是应用层的协议。因此通过这些协议封装的包，需要交给下一层，直到最底层，才能通过网卡，网线等硬件进行数据传输。</p>
<p>传输层</p>
<p>应用层的下一层是传输层。传输层有面向连接的TCP协议和无连接的UDP协议。面向连接的TCP协议会保证这个包能够到达目的地，如果一次没有到达就会重新发送，直到送达。</p>
<p>而面向无连接的UDP协议是尽最大努力交付，并不能保证可靠交付，其优点就是对系统资源要求少，程序结构简单。</p>
<p>因此，两种协议有各自的适用场景。对数据可靠性要求高的，例如支付场景可以选用TCP协议，而对数据可靠性要求没那么高，但是希望不要占用太多系统资源的，例如视频通话场景，则可以选用UDP协议。</p>
<p>网络层</p>
<p>当包在传输层封装完毕之后，就会继续交给传输层的下一层，也就是网络层。网络层的协议是IP协议。IP协议里面就有源IP和目标IP地址，也就是浏览器所在机器的IP地址，和所要访问的目标网站的IP地址。所以，刚才我们利用DNS协议通过网站URL查找到的IP地址，就在这里派上用场了！</p>
<p>知道了目标IP地址，一般我们不能直接找到他，除非这个地址是在本地。而我们访问的网站，一般都是在外面，所以我们要离开本地出去。怎么去呢，就要通过网关。</p>
<p>你可以查看一下本地机器的IP配置，linux下通过ifconfig命令就可以查看。这个IP配置可能是你自己或者网络管理员手动配置的，也可能是自动配置的。如果是自动配置，会通过DHCP协议进行配置，这里就先不展开来说了。</p>
<p>本机的IP配置里面有一个网关的IP地址，因此要先找到网关。通过IP地址怎么找到网关呢？大家应该知道，每一个网卡都有一个全世界唯一的MAC地址，这个是在出厂的时候就被厂家设定好了的。因此只要我们知道网关的MAC地址，就一定能找到它了。</p>
<p>网络访问层</p>
<p>所以，我们有了网关的IP地址，再通过ARP协议发出询问，网关就会答复一个它的MAC地址。此时，网络层的包就可以交给下一层了，也就是网络访问层，在这一层里封装了本地的MAC地址和网关的MAC地址。</p>
<p>网关一般是路由器，它收到包之后，会判断如何走才能到达目标IP。当然到达目标IP可能会通过多个网关，那么如何进行判断到达目标IP的路径呢？</p>
<p>网关之间会通过路由协议进行沟通，常用的路由协议有OSPF和BGP。每一个网关都会判断这个包里的目标IP地址是不是在自己的网络里，如果不在，则会告诉你，下一步应该去哪个网关比较近，直到来到目标IP所在网络的网关，这个网关知道目标IP的MAC地址，也就抵达了目的地。</p>
<p>所以就这样经过多个网关，最终我们的数据包就到达了目标IP对应的机器上。</p>
<p>送达目标机器，进行处理<br>应用层使用了HTTP协议进行超文本传输，对于服务器后台处理应该有telnet远程调用协议响应用户，DNS协议获取网络地址，即IP地址；打开网页，网页显示用到了表示层的HTML协议；<br>另外必然用到了传输层的TCP和网络层的IP协议；网络层ARP协议获取物理地址；ICMP协议控制信息的传递，还有很多吧，我就不知道了<br>HTTP，TCP，IP，DNS，ARP，ICMP必然有</p>
<hr>
<p>tcp三次握手<br>在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.</p>
<p>第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； </p>
<p>SYN：同步序列编号(Synchronize Sequence Numbers)<br>第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； </p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.<br>syn泛洪攻击<br>这幅图呢就是TCP的通信的三次握手，如果说攻击端，发送完第一次握手的数据后，然后就”消失”了，那么服务器就会不断的发送第二次握手的数据，可是攻击端的人找不到了。于是，服务器的资源大量被消耗，直到死机为止。当然了，如果要完全弄懂机制，需要对TCP有相当深入的了解。</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/disshu.github.io/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

